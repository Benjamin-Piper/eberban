# eberban PEG grammar - v0.29
# ===========================

# GRAMMAR
# main rule, allow language version/dialect annotation
text <- parser_version? text_1
parser_version <- BU_clause (parser_version_short / parser_version_long)
parser_version_long <- borrowing_unit parser_version_number?
parser_version_short <- parser_version_number
parser_version_number <- spaces? (TA / BQ)+

# main text rule
text_1 <- (free_indicator / free_discursive / free_parenthetical)* paragraphs? spaces? EOF?

# text structure
paragraphs <- paragraph (&PU_clause paragraph)*
paragraph <- PU_clause? sentence (&(PA_clause / PO_clause) sentence)*
sentence <- function / sentence_scope / sentence_fragments

function <- PO_clause function_name arguments_list? scope
function_name <- GA_clause / unit_compound / unit_root
sentence_scope <- PA_clause_elidible scope PAI_clause_elidible

sentence_fragments <- PA_clause_elidible fragment+ PAI_clause_elidible
fragment <- DA_clause / FA_clause / VA_clause / SA_clause / ZA_clause

# scope
scope <- scope_bind_connectives / scope_1
scope_bind_connectives <- scope_1 (DA_clause scope)

scope_1 <- scope_plural / scope_2
scope_plural <- scope_2 (BA_clause scope_1)

scope_2 <- sequential

# bindings
sequential <- sequential_neg / sequential_unit sequential?
sequential_neg <- BI_clause sequential_unit+
sequential_unit <- unit explicit_binding?
explicit_binding <- explicit_binding_va explicit_binding_fa* VAI_clause_elidible
explicit_binding_va <- BI_clause? VA_clause scope 
explicit_binding_fa <- BI_clause? FA_clause scope

# predicate unit
unit <- (SA_clause / ZA_clause)* unit_1
unit_1 <- borrowing / quote / subscope / variable / unit_root / unit_number_string / unit_compound
unit_root <- free_prefix* spaces? root free_post*
unit_number_string <- free_prefix* spaces? number_string free_post*
unit_compound <- free_prefix* spaces? compound free_post*

# borrowings
borrowing <- free_prefix* (spaces? borrowing_unit)+ BE_clause_elidible free_post*

# quotes
quote <- grammatical_quote / one_word_quote / foreign_quote
grammatical_quote <- XA_clause text_1 XAI_clause
one_word_quote <- XE_clause spaces? native_word
foreign_quote <- XO_clause spaces? foreign_quote_open spaces foreign_quote_content foreign_quote_close free_post*
foreign_quote_content <- (foreign_quote_word spaces)*

# sub-scopes
subscope <- PE_clause arguments_list? function* scope PEI_clause_elidible
arguments_list <- (KA_clause / GA_clause)+ PI_clause

# string (numbers / literals)
number_string <- (TA_clause / BQ_clause)+ BE_clause_elidible

# variables
variable <- MA_clause / BO_clause? KA_clause / BO_clause? GA_clause

# free prefix
free_prefix <- JE_clause / JU_clause

# free suffix
free_post <- JEI_clause / free_discursive / free_indicator / free_parenthetical / free_subscript
free_subscript <- JA_clause number_string
free_discursive <- JAI_clause unit
free_indicator <- CA_clause
free_parenthetical <- JO_clause text_1 JOI_clause

# PARTICLES CLAUSES
BA_clause           <- spaces? BA                               # plural value builder (with)
BE_clause           <- spaces? BE                               # miscellaneous terminator
BE_clause_elidible  <- BE_clause?
BI_clause           <- free_prefix* spaces? BI free_post*       # wide-scope negation
BO_clause           <- spaces? BO                               # variable assignement
BU_clause           <- spaces? BU                               # parser version/dialect
BQ_clause           <- free_prefix* spaces? BQ                  # letters
CA_clause           <- free_prefix* spaces? CA                  # free suffix (indicator / marker)
DA_clause           <- free_prefix* spaces? DA free_post*       # binding logical connectives
FA_clause           <- free_prefix* spaces? FA free_post*       # continue explicit binding
GA_clause           <- free_prefix* spaces? GA free_post*       # pred variables
JA_clause           <- free_prefix* spaces? JA                  # free subscript
JAI_clause          <- free_prefix* spaces? JAI                 # free discursive (pred)
JE_clause           <- spaces? JE                               # free scope starter
JEI_clause          <- spaces? JEI                              # free scope termiator
JO_clause           <- free_prefix* spaces? JO                  # free parenthetical started (text)
JOI_clause          <- free_prefix* spaces? JOI                 # free parenthetical terminator
JU_clause           <- spaces? JU                               # free prefix / scope starter
KA_clause           <- free_prefix* spaces? KA free_post*       # individual variables
MA_clause           <- free_prefix* spaces? MA free_post*       # intrinsic variables (pronouns, ...)
PA_clause           <- free_prefix* spaces? PA free_post*       # pred scope starter
PA_clause_elidible  <- PA_clause?
PAI_clause          <- free_prefix* spaces? PAI free_post*      # pred scope terminator
PAI_clause_elidible <- PAI_clause?
PE_clause           <- free_prefix* spaces? PE free_post*       # pred subscope starter
PEI_clause          <- free_prefix* spaces? PEI free_post*      # pred subscope terminator
PEI_clause_elidible <- PEI_clause?
PI_clause           <- free_prefix* spaces? PI free_post*       # pred scope arguments terminator
PO_clause           <- spaces? PO                               # pred variable affectation
PU_clause           <- free_prefix* spaces? PU free_post*       # paragraph marker
SA_clause           <- free_prefix* spaces? SA free_post*       # place binding tag
TA_clause           <- free_prefix* spaces? TA                  # numbers/digits
VA_clause           <- free_prefix* spaces? VA free_post*       # starts explicit binding clause
VAI_clause          <- free_prefix* spaces? VAI free_post*      # explicit binding clause terminator
VAI_clause_elidible <- VAI_clause?
XA_clause           <- free_prefix* spaces? XA                  # grammatical quote starter
XAI_clause          <- free_prefix* spaces? XAI free_post*      # grammatical quote terminator
XE_clause           <- free_prefix* spaces? XE                  # one word quote
XO_clause           <- free_prefix* spaces? XO                  # foreign quote
ZA_clause           <- free_prefix* spaces? ZA                  # pred unit transformation

# PARTICLE FAMILIES
BA    <- &particle (b a)
BE    <- &particle (b &e haeiou)
BI    <- &particle (b i)
BO    <- &particle (b o)
BU    <- &particle (b u)
BQ    <- &particle (consonant q / particle2 )
CA    <- &particle (c haeiou)
DA    <- &particle (d aeiou)
FA    <- &particle (f haeiou)
GA    <- &particle (g haeiou)
JA    <- &particle (j a)
JAI   <- &particle (j a i)
JE    <- &particle (j e)
JEI   <- &particle (j e i)
JO    <- &particle (j o)
JOI   <- &particle (j o i)
JU    <- &particle (j &u haeiou)
KA    <- &particle (k haeiou)
MA    <- &particle (m haeiou)
PA    <- &particle (p a)
PAI   <- &particle (p a i)
PE    <- &particle (p e)
PEI   <- &particle (p e i)
PI    <- &particle (p i)
PO    <- &particle (p o)
PU    <- &particle (p &u haeiou)
SA    <- &particle (s haeiou)
TA    <- &particle (t haeiou) / digit
VA    <- &particle !(VAI &post_word) (v haeiou)
VAI   <- &particle (v a i)
XA    <- &particle !(XAI &post_word) (x &a haeiou)
XAI   <- &particle (x a i)
XE    <- &particle (x &e haeiou)
XO    <- &particle (x &o haeiou)
ZA    <- &particle (z haeiou)

# MORPHOLOGY
# - Forein text quoting
foreign_quote_open <- native_word
foreign_quote_word <- (!spaces .)+ 
foreign_quote_close <- native_word

# - Compounds
compound <- (compound_1 / compound_2 / compound_3 / compound_n) &post_word
compound_1 <- a compound_word
compound_2 <- e compound_word compound_word
compound_3 <- i compound_word compound_word compound_word
compound_n <- o compound_word (!compound_n_end compound_word)* compound_n_end
compound_n_end <- spaces? o &post_word
compound_word <- spaces? (borrowing_unit / native_word)

# - Foreign words
borrowing_unit <- u borrowing_content borrowing_end
borrowing_content <- foreign_word
borrowing_end <- (pause_char / space_char / EOF)
foreign_word <- (initial_consonant_pair / consonant)? haeiouq (consonant_cluster haeiouq)* consonant? consonant?

# - Native words
native_word <- root / particle
particle <- !sonorant (particle1 / particle2)  &post_word
root <- !sonorant (root1 / root2 / root3) &post_word

particle1 <- consonant haeiouq
particle2 <- &q haeiouq (sonorant haeiouq)*

root1 <- consonant haeiouq (sonorant haeiouq)+ sonorant?
root2 <- consonant haeiouq sonorant
root3 <- initial_consonant_pair haeiouq (sonorant haeiouq)* sonorant?

# - Legal clusters
haeiouq <- aeiouq+ (h aeiouq+)*
haeiou <- aeiou+ (h aeiou+)*
aeiouq <- aeiou / q !q
aeiou <- a / e / i / o / u

consonant_cluster <- (!(sonorant sonorant sonorant) consonant consonant? consonant? !consonant)
initial_consonant_pair <- &initial consonant consonant !consonant
initial <- (plosib / sibilant? other? liquid?) !consonant

plosib <- plosive sibilant
consonant <- (voiced / unvoiced / liquid / m / n) 
liquid <- (l / r) 
other <- (p / t / k / f / x / b / d / g / v / m / n !liquid)
plosive <- (t / d / k / g / p / b)
sibilant <- (c / s / j / z) 
sonorant <- (l / n / r) # technically "alveolar sonorant" as "m" is not included
voiced <- (b / d / g / j / v / z) 
unvoiced <- (c / f / k / p / s / t / x) 

# Legal letters
a <- [aA] !a # <LEAF>
e <- [eE] !e # <LEAF>
i <- [iI] !i # <LEAF>
o <- [oO] !o # <LEAF>
u <- [uU] !u # <LEAF>
q <- [qQ] # <LEAF>

h <- [hH] !h # <LEAF>
l <- [lL] !l # <LEAF>
m <- [mM] !m # <LEAF>
n <- [nN] !n # <LEAF>
r <- [rR] !r # <LEAF>

b <- [bB] !b !unvoiced # <LEAF>
d <- [dD] !d !unvoiced # <LEAF>
g <- [gG] !g !unvoiced # <LEAF>
v <- [vV] !v !unvoiced # <LEAF>
j <- [jJ] !j !z !unvoiced # <LEAF>
z <- [zZ] !z !j !unvoiced # <LEAF>
s <- [sS] !s !c !voiced # <LEAF>
c <- [cC] !c !s !x !voiced # <LEAF>
x <- [xX] !x !c !k !voiced !liquid # <LEAF>
k <- [kK] !k !x !voiced # <LEAF>
f <- [fF] !f !voiced # <LEAF>
p <- [pP] !p !voiced # <LEAF>
t <- [tT] !t !voiced # <LEAF>

# - Spaces / Pause
post_word <- (pause_char &aeiouq) / !sonorant &consonant / spaces
spaces <- initial_spaces (pause_char &aeiouq)? / pause_char &aeiouq / EOF
initial_spaces <- (hesitation / space_char)+
hesitation <- (space_char+ pause_char? / pause_char) !(q h q) q+ !(pause_char pause_char) (pause_char? &space_char / &(pause_char q) / pause_char / EOF)
space_char <- [\t\n\r?!\u0020]

# - Special characters
pause_char <- (['.]) !pause_char
EOF <- !.
digit <- [.0123456789] # <LEAF2>